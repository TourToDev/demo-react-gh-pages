const articleCollection = {
    'goodbye-clean-code':'# Goodbye, Clean Code\r\n\r\nJanuary 11, 2020 • ☕️ 5 min read\r\n\r\nIt was a late evening.\r\n\r\nMy colleague has just checked in the code that they’ve been writing all week. We were working on a graphics editor canvas, and they implemented the ability to resize shapes like rectangles and ovals by dragging small handles at their edges.\r\n\r\nThe code worked.\r\n\r\nBut it was repetitive. Each shape (such as a rectangle or an oval) had a different set of handles, and dragging each handle in different directions affected the shape’s position and size in a different way. If the user held Shift, we’d also need to preserve proportions while resizing. There was a bunch of math.\r\n\r\nThe code looked something like this:\r\n\r\n``` js\r\nlet Rectangle = {\r\n  resizeTopLeft(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeTopRight(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeBottomLeft(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeBottomRight(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n};\r\n\r\nlet Oval = {\r\n  resizeLeft(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeRight(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeTop(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeBottom(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n};\r\n\r\nlet Header = {\r\n  resizeLeft(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeRight(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },  \r\n}\r\n\r\nlet TextBlock = {\r\n  resizeTopLeft(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeTopRight(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeBottomLeft(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n  resizeBottomRight(position, size, preserveAspect, dx, dy) {\r\n    // 10 repetitive lines of math\r\n  },\r\n};\r\n```\r\n\r\nI see now that my “refactoring” was a disaster in two ways:\r\n\r\n* Firstly, I didn’t talk to the person who wrote it. I rewrote the code and checked it in without their input. Even if it was an improvement (which I don’t believe anymore), this is a terrible way to go about it. A healthy engineering team is constantly building trust. Rewriting your teammate’s code without a discussion is a huge blow to your ability to effectively collaborate on a codebase together.\r\n\r\n\r\n* Secondly, nothing is free. My code traded the ability to change requirements for reduced duplication, and it was not a good trade. For example, we later needed many special cases and behaviors for different handles on different shapes. My abstraction would have to become several times more convoluted to afford that, whereas with the original “messy” version such changes stayed easy as cake.',
    'my-decade-in-review':"# My Decade in Review\r\n\r\n***January 1, 2020 • ☕️☕️☕️☕️☕️ 26 min read***\r\n\r\n\r\nI started this decade as a first-year college student fresh out of high school. I was 17, didn’t have a job, didn’t have any industry connections, and really didn’t know shit. And now you’re reading my blog! I would have been proud.\r\n\r\nI’ve told bits and pieces of my story on different podcasts. Now feels like an appropriate time to write down the parts that were most memorable to me.\r\n\r\nEvery person’s story is unique and not directly reproducible. I’ve benefited immensely from the privilege of being born in an upper middle class family and looking like a typical coder stereotype. People took chances on me. Still, I hope that sharing my story can be helpful to compare our experiences. Even if our circumstances are too different, at least you might find some of it entertaining.\r\n\r\n2010\r\nI was born in Russia and I finished the high school there in 2009. In Russia, higher education is free if you do well enough at tests. I tried my chances with a few colleges. I was particularly hoping to get into one college whose students often won programming competitions (which I thought was cool at the time).\r\n\r\nHowever, it turned out my math exam scores weren’t good enough. So there were not many options I could choose from that had to do with programming. From the remaining options, I picked a college that gave Macbooks to students. (Remember the white plastic ones with GarageBand? They were the best.)\r\n\r\nBy the summer of 2010, I had just finished my first year there. It turned out that there wasn’t going to be much programming in the curriculum for two more years. But there was a lot of linear algebra, physics, and other subjects I didn’t find particularly interesting. Everything was well in the beginning, but I started slacking off and skipping lectures that I had to wake up early for. My gaps in knowledge gradually snowballed, and most of what I remember from my first year in the university is the anxiety associated with feeling like a total failure.\r\n\r\nEven for subjects I knew well, things didn’t quite go as I planned. Our English classes were very rudimentary, and I got a verbal approval from the teacher to skip most of them. But when I came for the final test, I wasn’t allowed to turn it in unless I pay money for hours of “catch up training” with the same teacher. This experience left me resentful and suspicious of higher education.\r\n\r\nAside from being a lousy student, I was also in my first serious relationship — and it wasn’t going very well either. I was unhappy, but I thought that you can solve this by continuing to be unhappy and “fixing” it. Unfortunately, I didn’t have the wisdom to get out of a non-working relationship for a few more years.\r\n\r\nNow onto the bright side. Professionally, 2010 was an exciting year for me. I got my first job as a software developer! Here’s how that happened.\r\n\r\nThere was a small venue close to my college that hosted different events. This venue was a “business incubator” — mind you, not a Silicon Valley kind of business incubator — but a tiny Russian one. I have no idea what businesses they “incubated”. However, they hosted a talk about software development, and I decided to check it out because I was starving for that kind of content. I didn’t know any programmers in real life, and I didn’t know meetups existed!\r\n\r\nI don’t remember what the talk was about now. But I knew the person who gave it was an executive in a Russian-American outsourcing company. I’ve been programming since 12, so I approached him and asked if they’re hiring. He gave me an email, I went through their test exercises, and in a few weeks got the job.\r\n\r\nI started at my first job during the summer of 2010. My salary was $18k/year (yes that’s 18 and not 180). This is peanuts in the developed world, but again, this was Russia — so the rent was cheap too. I immediately moved out of my mom’s apartment and started renting a room for $150 a month. I was excited. With my first salary, I bought an iPhone and marvelled at how good the UI was.\r\n\r\nSummer came and went, and then the second college year started. But it started without me. Now that I was doing actual work and people payed me for it, I lost my last bits of motivation for sitting at lectures and doing exercises. I stopped going there and didn’t show up for the midterm exams. I returned my Macbook. The only time I went there again was five years later, to pick up my papers.\r\n\r\nA short digression. I’m not saying colleges are worthless, or that you should drop out. It was the right decision for me, but I knew I could fall back on my family (more on that later) when things are tough. I also already had a job.\r\n\r\nI had the privilege to be seen as knowledgeable by default due to my background (a guy who started coding early). People who don’t fit this stereotype often get a degree just to gain access to that assumed competence. So there’s that.",
    'whats-the-react-team-principle':"# What Are the React Team Principles?\r\nDecember 25, 2019 • ☕️ 5 min read\r\n\r\n\r\nDuring my time on the React team, I’ve been lucky to see how Jordan, Sebastian, Sophie and other tenured team members approach problems. In this post, I’m distilling what I learned from them into a few high-level technical principles. These principles aren’t meant to be exhaustive. This is my personal attempt to formalize observations about how the React team operates — other team members may have different perspectives.\r\n\r\n## UI Before API\r\nEvery abstraction has its own quirks when deployed at scale. How do those quirks manifest themselves in the user interfaces? Can you tell when an app is built with a certain abstraction?\r\n\r\nAbstractions have a direct effect on the user experiences — enabling, perpetuating, or even making some of them impossible. This is why when designing APIs, we don’t start with the abstraction itself. Instead, we start with the desired user experience, and work backwards to the abstraction.\r\n\r\nSometimes as we work backwards, we realize we need to change the whole approach to enable the right user experience. We can’t see that if we start with the API. So we put UI before API.\r\n\r\n## Absorb the Complexity\r\nMaking React internals simple is not a goal. We are willing to make React internals complex if that complexity lets product developers keep their code easier to understand and modify.\r\n\r\nWe want to allow the product development be decentralized and collaborative. Often, that means that we bear the brunt of centralization. React can’t be split into small simple loosely coupled modules because in order to do its job, something has to act as the coordinator. That’s what React is.\r\n\r\nBy raising the abstraction level, we make product developers more powerful. They benefit from the system as a whole having certain predictable properties. But this means that every new N+1st feature we introduce has to work well with all of the N existing features. This is why contributing new features to React is so difficult both at the design and the implementation side. This is why we don’t get many “core” open source contributions.\r\n\r\nWe absorb the complexity to stop its bleeding into the product code.\r\n\r\n## Hacks, Then Idioms\r\nEvery API creates new restrictions. Sometimes these restrictions prevent people from shipping delightful user experiences. We provide escape hatches so people can work around us where necessary.\r\n\r\nHacks can’t survive for long because they are fragile. Product developers then have to choose whether they prefer to take a maintenance hit by supporting the hack, or to degrade the user experience but remove the hack. Often, the user experience loses — or the hack prevents further improvements to it.\r\n\r\nWe need to allow hacks using escape hatches, and observe which hacks people put in practice. Our job is to eventually provide an idiomatic solution for hacks that exist in the name of better user experience. Sometimes, a solution might take years. We prefer a flexible hack to entrenching a poor idiom.\r\n\r\n## Enable Local Reasoning\r\nThere aren’t many things you can do in a code editor. You can add some lines or remove them. Or copy and paste something. And yet many abstractions make these basic operations difficult.\r\n\r\nFor example, MVC frameworks tend to make it unsafe to delete some part of the rendering output. This is because parents imperatively call methods on their children (which aren’t there after you removed them). By contrast, in React it’s usually safe to just delete lines of code in your render tree. This is a win.\r\n\r\nWhen designing APIs, we assume the person only has local knowledge about the piece of code they’re working on. When the intended effect is local, we want to prevent surprising outcomes. For example, we usually expect adding code to be safe. We expect removing and changing code to clearly point to the whole trail of code that needs to be considered as part of this change. We can’t assume the knowledge of the whole codebase when changing a single file.\r\n\r\nWhen something isn’t safe to do, we want the developer to discover the full effects of their change as early as possible. Warnings, type checks, and developer tooling can help, but they are limited by the API design. If the API is not restrictive enough, local reasoning is impossible. For example, this is why findDOMNode() is bad. It requires global knowledge.\r\n\r\n## Progressive Complexity\r\nSome frameworks choose to have a fork in the road. They provide two ways to do something: an easy way, and a powerful way. The easy way is nice to learn, but at some point you hit a wall. When that happens, you have to undo your past work, and reimplement it differently.\r\n\r\nWe prefer that implementing a complex thing isn’t too much different in structure from implementing a simple thing. For example, we don’t offer a separate template DSL “for the simple cases” because it creates a fork in the road. We’re willing to compromise on the barrier to entry if we think you’re going to want the fully featured mechanism soon anyway.\r\n\r\nSometimes, the “easy way” and the “powerful way” are two different frameworks. Then you also have to rewrite. It’s nice when we can avoid that, too. For example, adding server rendering is an optimization that requires some extra effort in React but not a full-on rewrite.\r\n\r\n## Contain the Damage\r\nTop-down tools like code budgets are important. However, over the long term, our standards will slip, features will ship under deadlines, and products will be unmaintained. When we can’t rely on everyone playing along, our role as a coordinator is to contain the damage.\r\n\r\nIf some UI code is slow or over budget, we need to do what we can to reduce its negative effects on loading time and interactions with other parts of the UI. Ideally, the developer should only “pay” for the features they use, and the user should only “pay” for the UI they interact with. Concurrent Mode features including Time Slicing and Selective Hydration are different levers to address that.\r\n\r\nBecause the library code overhead is relatively stable but the application code is unbounded, we tend to focus on containing the damage in the application code instead of the fixed cost of library code.\r\n\r\n## Trust the Theory\r\nSometimes, we know an approach is a dead end. Maybe it works today, but we are already aware of its limitations, and they fundamentally prevent us from achieving the desirable user experience. We pivot away from investing into such approach as soon as it’s viable to do so.\r\n\r\nWe want to avoid getting stuck in a local maxima. If another approach makes a lot more sense in theory, we’re willing to invest the effort to get there, even if it takes many years. There will be many obstacles and pragmatic compromises we might have to make to get there. But we trust that if we keep chipping away at them, eventually the theory wins.\r\n\r\nWhat Are Your Team’s Principles?\r\nThese are a few fundamental principles I’ve observed in how we work, but I’ve probably missed a bunch of them. I also haven’t touched on the less technical principles around how we roll out APIs, communicate changes, and so on. That could be a topic for another day.\r\n\r\nDoes your team have a set of principles? I’d love to hear about them.\r\n"
}
export default articleCollection;
